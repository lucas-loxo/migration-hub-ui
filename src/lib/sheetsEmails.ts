import { getAccessToken } from './google'
import { SHEET_MAPPING } from '../config/sheetMapping'
import { getAllEmailThreads } from './emails'

const SHEETS_ID = (import.meta as any).env?.VITE_SHEETS_ID as string | undefined

/**
 * Creates a new outgoing email message row in MH_EmailMessages.
 * Note: MessageID (column A) is auto-generated by ARRAYFORMULA, so we skip it.
 */
export async function createOutgoingEmailMessage(params: {
  token: string
  threadId: string
  migrationId: string
  fromEmail: string
  toEmails: string
  ccEmails?: string
  bccEmails?: string
  subject: string
  bodyPlain: string
  isAiDraft?: boolean
  aiModel?: string
  aiDraftBodyPlain?: string
  wasEditedByUser?: boolean
}): Promise<void> {
  const { 
    token, 
    threadId, 
    migrationId, 
    fromEmail, 
    toEmails, 
    ccEmails, 
    bccEmails, 
    subject, 
    bodyPlain,
    isAiDraft = false,
    aiModel,
    aiDraftBodyPlain,
    wasEditedByUser = true,
  } = params

  const accessToken = token || getAccessToken()
  if (!accessToken) {
    throw new Error('Not authenticated. Please sign in to Google.')
  }

  const id = SHEETS_ID || '1aSy-ypUF95hLmQkIsKmqnD0RMJ4AQ-rCHdeg7OXSj4k'
  const tabName = 'MH_EmailMessages'

  // Verify tab exists in mapping
  if (!SHEET_MAPPING.some((m) => m.tabName === tabName)) {
    throw new Error(`Sheet tab "${tabName}" not found in SHEET_MAPPING`)
  }

  const nowIso = new Date().toISOString()

  // GmailMessageId will be empty initially and populated later by Zapier/Gmail
  const gmailMessageId = ''

  // Look up GmailThreadId from MH_EmailThreads using the internal ThreadID
  // This value is used by Zapier to reply via Gmail in the correct thread
  // It is looked up from MH_EmailThreads based on internal ThreadID
  let gmailThreadId = ''
  try {
    const threads = await getAllEmailThreads(accessToken)
    const matchingThread = threads.find((t) => 
      String(t.ThreadID || '').trim().toLowerCase() === String(threadId).trim().toLowerCase()
    )
    if (matchingThread?.GmailThreadId) {
      gmailThreadId = String(matchingThread.GmailThreadId)
    }
  } catch (error) {
    // Log but don't fail - GmailThreadId lookup is best-effort
    console.warn('[MH_EmailMessages] Failed to lookup GmailThreadId:', error)
  }

  // IMPORTANT: Column A (MessageID) is generated by an ARRAYFORMULA in Sheets.
  // Never write to column A from the app. All writes start at column B.
  // Build row values array starting at column B (index 0 maps to column B)
  // Column order: B=ThreadID, C=MigrationID, D=GmailMessageId, E=GmailThreadId, F=Direction, etc.
  const rowValues = [
    String(threadId),          // B: ThreadID
    String(migrationId),      // C: MigrationID (string, e.g. "M-0061")
    gmailMessageId,          // D: GmailMessageId (empty initially, populated later by Zapier/Gmail)
    gmailThreadId,            // E: GmailThreadId (looked up from MH_EmailThreads, used by Zapier to reply in correct Gmail thread)
    'outgoing',                // F: Direction ("incoming" | "outgoing")
    'ready_to_send',           // G: Status ("ready_to_send" | "sent" | "received")
    'App',                     // H: Source ("App" | "Zapier")
    String(fromEmail),         // I: FromEmail
    '',                        // J: FromName
    String(toEmails),          // K: ToEmails
    String(ccEmails ?? ''),    // L: CcEmails
    String(bccEmails ?? ''),   // M: BccEmails
    String(subject),           // N: Subject
    String(bodyPlain),         // O: BodyPlain
    '',                        // P: BodyHtml
    0,                         // Q: HasAttachments
    '',                        // R: GmailThreadUrl
    '',                        // S: SentAt (ISO string or "")
    nowIso,                    // T: CreatedAt
    nowIso,                    // U: UpdatedAt
    isAiDraft,                 // V: IsAiDraft
    String(aiModel || ''),     // W: AiModel ('gemini' | 'openai' | '')
    aiDraftBodyPlain || '',    // X: AiDraftBodyPlain
    wasEditedByUser,           // Y: WasEditedByUser
    ''                         // Z: ErrorFlag
  ]

  // IMPORTANT: Column A (MessageID) is generated by an ARRAYFORMULA in Sheets.
  // Never write to column A from the app. All writes start at column B.
  const range = `${tabName}!B2:Z`
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${id}/values/${encodeURIComponent(range)}:append?valueInputOption=USER_ENTERED`
  
  console.log(
    '[MH_EmailMessages append DEBUG]',
    'range=',
    range,
    'rowValues=',
    JSON.stringify(rowValues),
    'length=',
    rowValues.length
  )
  const res = await fetch(url, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      values: [rowValues],
    }),
  })

  if (!res.ok) {
    const err = await res.text()
    throw new Error(`Sheets API error ${res.status}: ${err || res.statusText}`)
  }

  // After successful write, notify Zapier for outgoing emails that need to be sent
  // This replaces Zapier's "New Spreadsheet Row" polling trigger with an immediate webhook POST
  // Zapier is now triggered via this backend webhook POST whenever an outgoing email row is created
  const direction = 'outgoing' // This function only creates outgoing emails
  const status = 'ready_to_send' // Status set above for emails that need to be sent
  
  if (direction === 'outgoing' && status === 'ready_to_send') {
    try {
      const zapierWebhookUrl = 'https://hooks.zapier.com/hooks/catch/25132117/u8cdq4h/'
      
      // Build payload with camelCase keys from the row data
      const payload = {
        threadId: String(threadId),
        migrationId: String(migrationId),
        gmailMessageId: String(gmailMessageId), // Empty initially, will be populated by Zapier/Gmail
        gmailThreadId: String(gmailThreadId), // Looked up from MH_EmailThreads, used by Zapier to reply in correct Gmail thread
        direction: direction,
        status: status,
        source: 'App',
        fromEmail: String(fromEmail),
        fromName: '', // Not provided in params
        toEmails: String(toEmails),
        ccEmails: String(ccEmails ?? ''),
        bccEmails: String(bccEmails ?? ''),
        subject: String(subject),
        bodyPlain: String(bodyPlain),
        bodyHtml: '', // Not provided in params
        hasAttachments: false,
        gmailThreadUrl: '', // Not provided in params
        sentAt: '', // Empty until sent
        createdAt: nowIso,
        updatedAt: nowIso,
        isAiDraft: isAiDraft,
        aiModel: String(aiModel || ''),
        aiDraftBodyPlain: aiDraftBodyPlain || '',
        wasEditedByUser: wasEditedByUser,
        errorFlag: '',
        messageId: '' // Auto-generated by ARRAYFORMULA, not available immediately
      }

      // Temporary log statement to confirm payload is populated
      console.log('[MH_EmailMessages] Zapier webhook payload:', JSON.stringify(payload, null, 2))

      // Convert payload to form-encoded data to avoid CORS preflight
      const formData = new URLSearchParams()
      Object.entries(payload).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          formData.append(key, String(value))
        }
      })

      const webhookRes = await fetch(zapierWebhookUrl, {
        method: 'POST',
        body: formData,
        // Do NOT set Content-Type header - let browser use default for form-encoded requests
        // This avoids CORS preflight issues
      })

      if (!webhookRes.ok) {
        console.error(
          `[MH_EmailMessages] Zapier webhook failed: ${webhookRes.status} ${webhookRes.statusText}`
        )
      }
    } catch (webhookError) {
      // Log error but don't fail the main operation
      console.error('[MH_EmailMessages] Zapier webhook error:', webhookError)
    }
  }
}

